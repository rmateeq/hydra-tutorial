## How are building A.I. capabilities different?

Computer programming has been around for over a century now. As the emergence of new and richer programming languages is witnessed, software engineering practices have also been maturing. From machine and assembly to C/C++, and then languages like Java, C#, and Python took expressibility and abstraction to the next levels. The paradigms kept emerging as the software world witnesses a shift from procedural to other paradigms like object-oriented and functional. On the other hand, the software development life cycle beginning with a simple sequential style now stands at the adoption of agile and DevOps practices.

Isn't it enough to enable the incorporation of AI into modern-day software? Well, not really! Because the purpose of computer programming has primarily been to produce specific software with very deterministic behavior mimicking the logic given to it. It does not aim to integrate any generic behavior, adaptation, or self-learning which is the aim of AI. In a nutshell, the purpose of AI is to enable computers to learn to adapt as new situations emerge based on their experience rather than waiting for the programmer to do explicit modifications.

Is it possible? Well, one example of a problem that can be solved with AI but not with legacy programming is speech recognition. Legacy programming techniques typically involve writing a set of rules that determine how the system should interpret incoming audio signals and convert them into text. However, these rules can be complex and difficult to maintain, and they may not be able to handle the wide range of accents, dialects, and speaking styles that exist in the real world. In contrast, AI techniques can be used to train a system to recognize speech patterns without relying on explicit rules. By analyzing large amounts of audio data and identifying patterns in the data, the system can learn to recognize different speech sounds and map them to corresponding text.

This approach has proven highly effective in applications such as virtual assistants, speech-to-text transcription, and automated call centers. By using AI techniques, these systems can achieve high levels of accuracy even in noisy or challenging environments, and they can adapt to new speech patterns and languages with minimal human intervention.

Let's visualize it from the perspective of app design. We can break down the AI/ML capability into two parts as shown in the diagram below. The first part may be regarded as the rules sub-layer that contains the domain knowledge, and the second part may be regarded as the inference sub-layer that applies the inference rules on available knowledge to draw the inferences. The major difference between rule-based AI and machine learning is that the prior requires the rules to be supplied to the system whereas the latter can learn, adapt, and generate its own rules. This is the main reason that renders machine learning more practical at solving problems that cannot be exhaustively modeled using legacy software engineering approaches.


<p align="center">
<img src="https://user-images.githubusercontent.com/7511849/227346470-b972d4e3-eb7b-4b6e-8f8f-b63f8d792ebd.png" width="550" height="550" />
</p>


The journey to use AI in designing applications and solving real-life problems that are otherwise challenging or even impossible, is ongoing and significant milestones have been achieved already. Let's shift the focus to different types of capabilities that AI can help build, and conventional programming and software engineering cannot.

